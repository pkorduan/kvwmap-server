#!/bin/bash
# Version 3.0.0

usage() {
  echo ""
  echo "Das Script führt Anweisungen für die Verwaltung des kvwmap-Servers aus. Es muss als Nutzer root ausgeführt werden wenn der Nutzer nicht zur Gruppe docker gehört.";
  echo "Dazu gehören Befehle zum Starten und Stoppen der Container aber auch solche zum Anzeigen von Stati und Laden von Konfigurationen und sonstige häufiger für die Administration benötigten Komandos."
  echo "Kontakt: peter.korduan@gdi-service.de"
  echo ""
  echo "Aufruf:";
  echo "dcm command [container|all] [network]";
  echo ""
  echo "Varianten von command und container:"
  echo "build gdal     Erzeugt ein neues Image pkorduan/gdal-ssh:${GDAL_IMAGE_VERSION} an Hand des lokalen Dockerfiles."
  echo "build kvwmap   Erzeugt ein neues Image pkorduan/kvwmap-server:${KVWMAP_IMAGE_VERSION} an Hand des lokalen Dockerfiles."
  echo "clean          Löscht alle beendeten Container und nicht getaggete images."
  echo "console mysql  Öffnet eine Console im Mysql Container."
  echo "console pgsql  Öffnet eine Console im PostgreSQL Container."
  echo "console web    Öffnet eine Console im Web Container"
  echo "create network Erzeugt ein Netzwerk je nach Namen im 3. Parameter network"
  echo "install        - Installiert auf dem Hostrechner den Docker-Server und Utilities zum Betrieb der Container,"
  echo "               - Richtet ggf. benötigte Verzeichnisse und lokale Dateien für den Betrieb der Container ein."
  echo "install all    Installiert die Voraussetzungen zum Betrieb aller Container."
  echo "install kvwmap Installiert die Voraussetzungen zum Betrieb des web Containers."
  echo "install pydio  Installiert pydio Image."
  echo "mysql client   Öffnet eine Komandozeile im mysql Client."
  echo "mysql start    Startet nur den Container mit der MySQL-Datenbank (mysql-server)"
  echo "mysql status   Zeigt den Status des MySQL Containers an."
  echo "mysql stop     Stoppt den MySQL Container und zeigt alle vorhandenen an."
  echo "mysql remove   Löscht den MySQL Container und zeigt die verbleibenden an. Der Container muss vorher gestoppt worden sein."
  echo "mysql run      Erzeugt und startet den MySQL Container mit dem Namen mysql-server."
  echo "pgsql client   Öffnet eine Komandozeile im psql Client."
  echo "pgsql start    Startet nur den Container mit der PostgreSQL-Datenbank (pgsql-server)."
  echo "pgsql status   Zeigt den Status des PostgreSQL-Datenbank Containers an."
  echo "pgsql stop     Stoppt den PostgreSQL Container und zeigt alle vorhandenen an."
  echo "pgsql remove   Löscht den PostgreSQL Container und zeigt die verbleibenden an. Der Container muss vorher gestoppt worden sein."
  echo "pgsql run      Erzeugt und startet den PostgreSQL Container mit dem Namen pgsql-server."
  echo "pgsql allowip <IP> Führt das Script allowip im postgres data Verzeichnis aus, welches die IP in die pg_hba.conf einträgt für einen externen Zugriff."
  echo "rebuild        Stoppt und löscht Container, löscht images, die neu gebildet werden sollen, bildet diese neu und erzeugt und startet danach Container neu."
  echo "rebuild all    Stoppt, löscht und restartet zum rebuild des Web Containers alle Container."
  echo "rebuild gdal   Stoppt und löscht den gdal Container, löscht und rebuild das image pkorduan/gdal-ssh:${GDAL_IMAGE_VERSION} neu und run gdal Container neu."
  echo "rebuild web    Macht ein Rebuild vom image kvwmap-server:#{KVWMAP_IMAGE_VERSION}."
  echo "reload         Das selbe wie bei rebuild, nur dass nicht das image lokal neu gebuildet wird, sondern das latest von Dockerhub geladen wird."
  echo "reload all     Läd alle Container neu."
  echo "reload web     Läd nur den Web Container neu."
  echo "reload proxy   Läd die Konfiguration vom Proxy-Container neu, z.B. nach Änderungen im Verzeichnis config/conf.d"
  echo "rm             Löscht Container."
  echo "rm all         Löscht alle Container."
  echo "rm mysql       Löscht nur den Container mysql-server."
  echo "rm pgsql       Löscht nur den Container pgsql-server."
  echo "rm web         Löscht nur den Container web."
  echo "rm network     Löscht das Netzwerk mit dem Namen aus dem 3. Parameter network"
  echo "rerun          Stoppt und löscht alle oder die angegebenen Container und erzeugt und startet sie danach wieder."
  echo "rerun all      Rerun für alle Container."
  echo "rerun gdal     Stopped und löscht nur den gdal Container und erzeugt und startet ihn anschließend neu."
  echo "rerun web      Stopped und löscht nur den web Container und erzeugt und startet ihn anschließend neu."
  echo "restart        Stoppt und löscht Container und erzeugt und startet sie neu wie beim Parameter run."
  echo "restart all    Führt es für alle Container aus."
  echo "restart web    Führt es nur für den web Container aus."
  echo "run            Erzeugt und startet alle oder den angegebenen Container."
  echo "run all        Erzeugt und startet alle Container."
  echo "run proxy      Erzeugt und startet nur den Container proxy."
  echo "run gdal       Erzeugt und startet nur den Container gdal."
  echo "run mysql      Erzeugt und startet nur den Container mysql-server."
  echo "run pgsql      Erzeugt und startet nur den Container pgsql-server."
  echo "run web        Erzeugt und startet nur den Container web."
  echo "show_ip        Zeigt die IP Adressen der Container an. Der Containername als zusätzlicher Parameter zeigt nur die IP dieses Containers an."
  echo "start          Startet alle oder den angegebenen Container."
  echo "start all      Startet alle Container."
  echo "start proxy    Startet den Proxy Container."
  echo "start mysql    Startet nur den Container mysql-server."
  echo "start pgsql    Startet nur den Container pgsql-server."
  echo "start pydio    Startet nur den Container pydio."
  echo "start web      Startet nur den Container web."
  echo "status         Listet Status der angegebenen Container auf."
  echo "status all     Listet den Status aller Container auf."
  echo "status mysql   Listet den Status des Containers mysql-server."
  echo "status pgsql   Listet den Status des Containers pgsql-server."
  echo "status web     Listet den Status des Containers web"
  echo "stop           Stoppt alle oder einen der angegebenen Container."
  echo "stop all       Stoppt alle Container."
  echo "stop mysql     Stoppt nur den Container mysql-server."
  echo "stop pgsql     Stoppt nur den Container pgsql-server."
  echo "stop web       Stoppt nur den Container web."
  echo "uninstall      Vorsicht, Stoppt und löscht Container, löscht Images und deinstalliert eingerichtete Verzeichnisse auf dem Host-Rechner."
  echo "uninstall all  Deinstalliert alle images."
  echo "uninsall gdal  Deinstalliert das gdal image pkorduan/gdal-ssh:${GDAL_IMAGE_VERSION} und die dazugehörigen lokalen Ressourcen auf dem Hostrechner."
  echo "uninstall kvwmap Deinstalliert kvwmap-server."
  echo "               Dazu gehört alles in  ${WWW_ROOT} sowie die Verzeichnisse db, etc und kvwmap-server"
  echo "               unter dem Installationsverzeichnis z.B. unter /home/gisadmin"
  echo "               Damit werden auch alle Daten und Datenbankinhalte gelöscht."
  echo "update cron    Aktualisiert umgehend die cronjobs des Nutzers gisadmin im Web Container durch die Eintragungen,"
  echo "               die mit kvwmap in die Datei /var/www/cron/crontab_gisadmin geschrieben wurden."
  echo ""
  echo "Als Netzwerknamen können alle in kvwmap-server/config/config definierten Cases verwendet werden. Defaultmäßig sind die kvwmap_prod, kvwmap_dev und kvwmap_test verfügbar."
  echo "Ohne Angabe des Netzwerknames wird kvwmap_prod verwendet!"
  echo "Beispiele:"
  echo "$0 start"
  echo "$0 stop"
  echo "$0 pgsql status"
  echo "$0 rerun web kvwmap_dev"
  echo ""
  echo "Je nach dem welche Erweiterungen in cargo-enabeld eingestellt sind gibt es weitere Befehle. Folgende sind derzeit aktiviert:"
  usage_cargos
}

usage_cargos() {
  #echo "Show usage of cargos."
  for cargo in "${CARGOS[@]}"
  do
    #echo "usage_$cargo"
    usage_$cargo
  done
}

debug() {
  if $DEBUG ; then
    echo $1
  fi
}

build_kvwmap_server() {
  TAG=$1
  if [ -z "$TAG" ] ; then
    TAG=$KVWMAP_IMAGE_VERSION
  fi
  cd $USER_DIR/kvwmap-server/docker
  docker build -t pkorduan/kvwmap-server:${TAG} .
}

build_gdal_image() {
  TAG=$1
  if [ -z "$TAG" ] ; then
    TAG="latest"
  fi
  echo "Build the image pkorduan/gdal-sshd:$TAG"
  cd $USER_DIR/gdal-sshd
  docker build -t pkorduan/gdal-sshd:$TAG .
}

call_cargo_cases() {
  #debug "Call cargo cases with Arguments '$1' and '$2' and '$3'"
  #echo "Call cargo cases with Arguments '$1' and '$2' and '$3'"
  any_case_found=false
  for cargo in "${CARGOS[@]}"
  do :
    #debug "Search for case $1 $2 in cargo $cargo"
    #echo "   Search for case $1 $2 in cargo $cargo cases_$cargo"
    cases_$cargo $1 $2 $3
    if $case_found ; then
      #echo "Found case in cargo $cargo $1 $2"
      any_case_found=true
    fi
  done
  debug "Any case found after call all cargo cases: $any_case_found"
  if ! $any_case_found ; then
    echo "$any_case_found nicht gefunden"
    echo "Gib nach $1 die Parameter $core_sub_cases"
    if [ "${#CARGOS[@]}" -gt "0" ] ; then
      printf "oder %s " "${CARGOS[@]}"
    fi
    echo "an."
  fi
}

# Bricht ab, wenn nutzer nicht root ist und nicht in docker gruppe
fail_unless_root() {
  dcm_user=$(id -nu)
  dcm_user_group=$(id -nG)
  # Wenn ausführender Nutzer nicht root ist
  if [ "${dcm_user}" != "root" ]; then
    # Prüfe ob ausführende Nutzer in Gruppe docker ist
    if [[ "$dcm_user_group" != *"docker"* ]] ; then
      echo "Nutzer ${dcm_user} ist nicht berechtigt das Script dcm auszuführen."
      echo "Führen Sie das Script als root aus oder fügen Sie den Nutzer ${dcm_user} mit dem Befehhl"
      echo "/usr/sbin/usermod -a -G docker ${dcm_user}"
      echo "zur Gruppe von docker hinzu."
      exit 1
    else
      echo "${dcm_user} in gruppe ${dcm_user_group}"
    fi
  fi
}

load_cargo() {
  #echo "Load cargo source code."
  #echo "Load Container Configurations in $CARGOPATH."
  #echo "Consider that they will loaded in the alphanumeric order of the symbolic links in $CARGOPATH."

  dcmfiles=($(find -L $CARGOPATH -name dcm))

  dcmfiles=($(echo "${dcmfiles[@]}" | sed 's/ /\n/g' | sort))

  for dcmfile in ${dcmfiles[@]}
  do
    #echo "Load dcmfile: ${dcmfile}"
    source $dcmfile
  done
  #echo "CARGOS: "
  #printf '%s\n' "${CARGOS[@]}"
  #echo ""
}

install_cargos() {
  for cargo in "${CARGOS[@]}"
  do :
    install_$cargo
  done
}

install_docker() {
  echo "Install docker auf dem Hostrechner ..."
  # Update debian repo
  apt-get update && apt-get install -y \
    apt-utils \
    curl \
    jq \
    sendemail \
    unzip \
    wget

  # install docker demon and client on host system if not exists already
  case `docker --version` in
    *Docker*)
      echo 'Docker schon installiert!'
      ;;
    *)
      echo 'Installiere docker ....'
      curl -sSL https://get.docker.com/ | sh
      mkdir $USER_DIR/docker/lib
      systemctl stop docker
      mv /var/lib/docker $USER_DIR/docker/lib
      ln -s $USER_DIR/docker/lib/docker /var/lib/docker
      systemctl start docker
      echo "Installiere docker-compose"
      sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
      sudo chmod +x /usr/local/bin/docker-compose
    ;;
  esac

  # enable memory and swap accounting. This prevent from
  # WARNING: Your kernel does not support cgroup swap limit. and
  # WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.
  # This setting affects only after rebooting the system
  sed -i \
    -e "s|GRUB_CMDLINE_LINUX=\"\"|GRUB_CMDLINE_LINUX=\"cgroup_enable=memory swapaccount=1\"|g" \
    /etc/default/grub
  update-grub

  git config --global user.email "peter.korduan@gdi-service.de"
  git config --global user.name "Peter Korduan"
}

install_kvwmap_images() {
  echo "Installiere Voraussetzungen für den Betrieb von kvwmap ..."

  /usr/sbin/usermod -a -G docker $OS_USER

  echo "
  Setze bash Einstellungen für user: ${OS_USER} ..."
  # set bash settings for web gis user
  cp /etc/skel/.bashrc $USER_DIR/.bashrc
  echo "
  export PATH=\$PATH:${USER_DIR}/kvwmap-server" >> $USER_DIR/.bashrc
  sed -i \
    -e "s|#alias ll=|alias ll=|g" \
    -e "s|alias rm=|#alias rm=|g" \
    $USER_DIR/.bashrc
  echo "alias l='ls -alh --color=yes'" >> $USER_DIR/.bashrc
  echo "export PS1=\"\[\e[0m\]\[\e[01;31m\]\u\[\e[0m\]\[\e[00;37m\]@\[\e[0m\]\[\e[01;34m\]\h\[\e[0m\]\[\e[00;37m\]:\[\e[0m\]\[\e[01;37m\]\w\[\e[0m\]\[\e[00;37m\] \\$ \[\e[0m\]\"" >> $USER_DIR/.bashrc
  echo "set nocompatible" >> $USER_DIR/.vimrc

  cp $USER_DIR/.bashrc ~/.bashrc
  cp $USER_DIR/.vimrc ~/.vimrc

  source ~/.bashrc

  echo "Erzeuge www_root Verzeichnis."
  mkdir -p $WWW_ROOT

  echo "Kopiere www Verzeichnisse die vordefinierte Daten enthalten, apps, cron, data, html."
  cp -R $USER_DIR/kvwmap-server/www/* $WWW_ROOT

  echo "
  Erzeuge restliche Verzeichnisstruktur für die Datenbank und Web-Anwendungen von kvwmap ..."
  # create directories
  mkdir -p $DB_ROOT/mysql \
           $DB_ROOT/postgresql/data \
           $USER_DIR/etc \
           $WWW_ROOT/logs \
           $WWW_ROOT/logs/apache2 \
           $WWW_ROOT/logs/cron \
           $WWW_ROOT/logs/pgsql \
           $WWW_ROOT/logs/mysql \
           $WWW_ROOT/tmp \
           $WWW_ROOT/cache \
           $WWW_ROOT/wms \
           $WWW_ROOT/data/synchro \
           $WWW_ROOT/data/upload \
           $WWW_ROOT/data/druckrahmen \
           $WWW_ROOT/data/bilder \
           $WWW_ROOT/data/alb \
           $WWW_ROOT/data/nachweise \
           $WWW_ROOT/data/recherchierte_antraege \
           $WWW_ROOT/data/festpunkte/archiv

  ln -s $WWW_ROOT $USER_DIR/www
  ln -s $DB_ROOT $USER_DIR/db

  echo "
  Kopiere Konfigurationsdateien für Apache Web-Server ..."
  cp -R $USER_DIR/kvwmap-server/etc/apache2 $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/gdal $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/mysql $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/postgresql $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/php5 $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/php $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/phpmyadmin $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/proj $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/web $USER_DIR/etc/

  echo "
  Erzeuge Unterverzeichnisse im Apache Konfigurationsverzeichnis..."
  mkdir -p $USER_DIR/etc/apache2/sites-enabled \
           $USER_DIR/etc/apache2/ssl \
           $USER_DIR/etc/apache2/letsencrypt

  echo "
  Erzeuge Links für den Zugriff auf die Datenbankverzeichnisse ..."
  # create links to have access to the postgres config files, even if the files do not exist yet
  ln -s $DB_ROOT/postgresql/data/pg_hba.conf $USER_DIR/etc/postgresql/pg_hba.conf
  ln -s $DB_ROOT/postgresql/data/postgresql.conf $USER_DIR/etc/postgresql/postgresql.conf

  echo "
  Setze Servername für Apache default Konfiguration ..."
  # Servername in Apache default Konfiguration eintragen
  sed -i -e "s|ServerName localhost|ServerName ${SERVER_NAME}|g" $USER_DIR/etc/apache2/sites-available/000-default.conf

  echo "
  Clone kvwmap von github ins Web-Verzeichnis ..."
  if [ ! -d "${WWW_ROOT}/apps/kvwmap" ]; then
    # clone kvwmap repository into apps
    git clone https://github.com/srahn/kvwmap.git $WWW_ROOT/apps/kvwmap
    cd $WWW_ROOT/apps/kvwmap
    git checkout develop
  fi

  echo "
  Erzeuge kvwmap custom Verzeichnisse für Fonts, Grafik, Symbole und Layouts ..."
  mkdir -p $WWW_ROOT/apps/kvwmap/custom/fonts \
           $WWW_ROOT/apps/kvwmap/custom/graphics \
           $WWW_ROOT/apps/kvwmap/custom/wappen \
           $WWW_ROOT/apps/kvwmap/custom/layouts \
           $WWW_ROOT/apps/kvwmap/custom/layouts/snippets \
           $WWW_ROOT/apps/kvwmap/custom/symbols

  touch $WWW_ROOT/apps/kvwmap/custom/layouts/custom.css

  wget -O $WWW_ROOT/apps/kvwmap/custom/wappen/Logo_GDI-Service_200x47.png https://gdi-service.de/public/kvwmap_resources/Logo_GDI-Service_200x47.png

  echo "#geo_name_search_field {
    width: 100%;
  }

  #search_div {
    display: none;
  }" >> $WWW_ROOT/apps/kvwmap/custom/layouts/custom.css

  cd $WWW_ROOT/apps

  echo "
  Setze Rechte auf kvwmap Datenverzeichnisse ..."
  chown -R $OS_USER.$OS_USER $USER_DIR $WWW_ROOT
  chmod -R g+w $WWW_ROOT

  echo "
  Setze Rechte auf logs Verzeichnisse ..."
  chown 999.gisadmin $WWW_ROOT/logs/pgsql
  chmod a+r $WWW_ROOT/logs/pgsql

  echo "
  Setze Rechte 600 auf .pgpass ..."
  chown root.root $USER_DIR/etc/postgresql/.pgpass
  chmod 600 $USER_DIR/etc/postgresql/.pgpass

  echo "
  Nächste Schritte zum installieren von kvwmap:"
  echo "    $ dcm run all"
  echo "    Browser öffnen mit der Adresse: https://${IP_EXTERN}/kvwmap/install.php"
  echo ""
  echo "Die Installation ist erfolgreich abgeschlossen."
  echo "Achtung Der Zugang als root ist jetzt von außen gesperrt!"
  echo "Sie können sich nur noch als gisadmin per ssh mit diesem Server verbinden."
}

is_stopped() {
  if [ "$(docker ps -a -q -f name=$1 -f status=exited)" ] ; then
    echo 'true'
  else
    echo 'false'
  fi;
}

is_running() {
  if [ "$(docker inspect --format="{{ .State.Running }}" $1 2> /dev/null)" == "true" ] ; then
    echo 'true';
  else
    echo 'false';
  fi;
}

migrate_to_mariadb() {
  echo "Migrate MySQL image to MariaDB..."
  # backup mysql-Databases
  stop_all_container
  remove_all_container
  # backup env_and_volume
  # overwrite env_and_volume from kvwmap-server
  run_all_container
  # restore mysql-Databases
}

ps_container() {
  if [ -z $1 ] ; then
    echo "Liste alle Container"
    docker ps -a
  else
    echo "Liste nur Container im Netzwerk $1"
    docker ps -a --filter network=$1 | sort -k 2
  fi
}

remove_all_container() {
  echo "Lösche alle Container ..."
  cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml rm -s"
  echo $cmd
  $cmd
  echo "Alle Container gelöscht."
}

remove_networks() {
  echo "Remove all unused networks"
  docker network prune -f
}

remove_network() {
  echo "Remove network ${network_name}"
  cmd="docker network rm ${network_name}"
  echo $cmd
  $cmd
}

remove_proxy_container() {
  echo "Entferne proxy Container."
  docker rm proxy
  echo "fertig"
}

remove_gdal_container() {
  remove_container gdal
}

remove_mysql_container() {
  remove_container mysql
}

remove_pgsql_container() {
  remove_container pgsql
}

remove_web_container() {
  remove_container web
}

remove_container() {
  echo "Entferne Container $1 in Netzwerk ${network_name}"
  cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml rm -s $1"
  echo $cmd
  $cmd
}

remove_all_images() {
  echo "Lösche alle Images ..."
  docker rmi $(docker images | awk "{print $3}")
  echo "Alle Images gelöscht."
}

run_all_container() {
  echo "Erzeuge und Starte alle Container im Netzwerk: ${network_name}"
  cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml up -d"
  echo $cmd
  $cmd
}

run_cargo_containers() {
  for cargo in "${CARGOS[@]}"
  do
    run_${cargo}_container
  done
}

run_gdal_container() {
  echo "Erzeuge und Starte container gdal im Netzwerk ${network_name}"
  cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml up -d gdal"
  echo $cmd
  $cmd
}

run_mysql_container() {
  echo "Erzeuge und Starte container mysql im Netzwerk ${network_name}"
  cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml up -d mysql"
  echo $cmd
  $cmd
}

run_pgsql_container() {
  echo "Starte container postgres im Netzwerk: ${network_name}"
  cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml up -d pgsql"
  echo $cmd
  $cmd
}

run_web_container() {
  echo "Starte container web im Netzwerk: ${network_name}"
  cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml up -d web"

#  if [ -n "${container_version}" ] ; then
#    source $USER_DIR/etc/web/env_and_volumes_${container_version}
#  else
#    source $USER_DIR/etc/web/env_and_volumes
#  fi

#  if [ -z "${web_hosts}" ]; then
#    web_hosts="--add-host=$DOMAIN_NAME:${IP_EXTERN} \
#               --add-host=$SERVER_NAME:${IP_EXTERN}"
#  fi

#  if [ -z "${web_ports}" ]; then
#    web_ports="-p 80:80 \
#               -p 443:443"
#  fi

#  create_bridge_network
#  echo "Starte web Container:"
#  cmd="docker run\
#    -h ${SERVER_NAME}-web-container${container_version}\
#    --name web${container_version}\
#    --network $network_name\
#    --net-alias web\
#    --restart=always\
#    $web_env_vars\
#    $web_volumes\
#    $web_hosts\
#    $web_ports\
#    -d ${KVWMAP_IMAGE}:${KVWMAP_IMAGE_VERSION}\
#  "
  echo $cmd
  $cmd
}

run_proxy_container() {
  source $USER_DIR/proxy/env_and_volumes
  if [ -z "${proxy_ports}" ]; then
    proxy_ports="-p 80:80 \
                 -p 443:443"
  fi

  cmd="\
    docker run \
      -h ${SERVER_NAME}-proxy-container \
      --name proxy \
      --restart=always \
      $proxy_env_vars \
      $proxy_volumes \
      $proxy_hosts \
      $proxy_ports \
      -d ${PROXY_IMAGE}:${PROXY_IMAGE_VERSION} \
  "
  echo "Starte Container proxy:"
  echo $cmd
  $cmd
  # connect container to all custom networks
  for custom_network_i in $(docker network ls --filter type=custom --format {{.Name}}); do
    echo "Füge Container proxy zu Netzwerk ${custom_network_i} hinzu"
    cmd="docker network connect $custom_network_i proxy"
    echo $cmd
    $cmd
  done
}

reload_proxy_container() {
  cmd="docker exec proxy nginx -s reload"
  echo "Reload Konfiguration des proxy Containers:"
  echo $cmd
  $cmd
}

test_proxy_container() {
  cmd="docker exec proxy nginx -t"
  echo "Teste proxy Container:"
  echo $cmd
  $cmd
}

show_all_container_ips() {
  docker inspect -f="Container {{.Name}} IP: {{ .NetworkSettings.Networks.${WEB_NETWORK}.IPAddress }}" $(docker ps -aq)
}

show_container_ip() {
  docker inspect -f="Container {{.Name}} IP: {{ .NetworkSettings.Networks.${WEB_NETWORK}.IPAddress }}" $1
}

show_container_status() {
  CONTAINER=$1
  echo "Status des Containers $CONTAINER:"
  RUNNING=$(docker inspect --format="{{ .State.Running }}" $CONTAINER 2> /dev/null)

  if [ $? -eq 1 ]; then
    echo "UNKNOWN - Container $CONTAINER does not exist."
    return 3
  fi

  if [ "$RUNNING" == "false" ]; then
    echo "CRITICAL - $CONTAINER is not running."
    return 2
  fi

  STARTED=$(docker inspect --format="{{ .State.StartedAt }}" $CONTAINER)
  NETWORK=$(docker inspect --format="{{ .NetworkSettings.IPAddress }}" $CONTAINER)

  echo "OK - $CONTAINER is running. IP: $NETWORK, StartedAt: $STARTED"
}

start_all_container() {
  echo "Startet alle existierenden Container."
  docker start mysql-server
  docker start pgsql-server

  # start_cargo_container

  start_gdal_container
  start_web_container
  docker ps
}

start_container() {
  container=$1
  if [ ! -z $container ] ; then
    if [ "$(is_running $container)" == "true" ]; then
      echo "Container $container läuft schon.";
    else
      if [ "$(is_stopped $container)" == "false" ]; then
        run_${container}_container
      else
        echo "Starte Container ${container} ..."
        docker start $container
      fi
    fi
  fi
}

start_gdal_container() {
  echo "Starte gdal Container."
  docker start gdal
}

start_web_container() {
  echo "Starte web Container."
  docker start web
}

stop_all_container() {
  echo "Stoppe alle Container. Bitte warten ..."
  docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml rm -s
  echo "Alle Container gestopped."
}

stop_container() {
  echo "Stoppe container $1 in Network: ${network_name}"
  cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml stop $1"
#  cmd="docker stop $1"
  echo $cmd
  $cmd
}

stop_proxy_container() {
  echo "Stoppe proxy Container. Bitte warten ..."
  docker stop proxy
  echo "fertig"
}

stop_gdal_container() {
#  if [ "$(docker ps -a -q -f name=gdal -f status=running)" ] ; then
  stop_container gdal
#  else
#    echo "Container gdal kann nicht gestoppt werden, weil er nicht läuft."
#  fi
}

stop_mysql_container() {
  stop_container mysql
}

stop_pgsql_container() {
  stop_container pgsql
}

stop_web_container() {
  stop_container web
}

uninstall_cargos() {
  for cargo in "${CARGOS[@]}"
  do :
    uninstall_$cargo
  done
}

uninstall_gdal() {
  echo "Deinstalliere das gdal image ..."
  echo "Funktion ist noch nicht implementiert!!!"
}

uninstall_kvwmap() {
  echo "Deinstalliere das kvwmap und dazugehörige images."
  fail_unless_root
  read -p "Wollen Sie kvwmap-server wirklich deinstallieren? (y/n)? " answer
  case ${answer:0:1} in
    y|Y )
      stop_all_container
      remove_all_container
      #remove_all_images
      echo "Lösche alles in ${WWW_ROOT} "
      ls -l $WWW_ROOT
      rm -RI $WWW_ROOT/*

      if [ ! -z "$USER_DIR" ] ; then
        echo "Lösche $DOCKER_ROOT, $DB_ROOT, $USER_DIR/etc, $USER_DIR/kvwmap-server, ${WWW_ROOT} und die links db und www in $USER_DIR"
        rm -RI $DOCKER_ROOT $DB_ROOT $USER_DIR/etc $USER_DIR/kvwmap-server $WWW_ROOT $USER_DIR/db $USER_DIR/www $USER_DIR/inithost.sh
      fi
      echo "So jetzt ist alles weg außer de Images. Zum Löschen der Images docker rmi $(docker images | awk \"{print $3}\") ausführen."
      echo "Zum neu installieren nach ${USER_DIR} wechseln und folgenden Befehle eingeben:"
      echo " git clone https://github.com/pkorduan/kvwmap-server.git"
      echo " kvwmap-server/dcm install kvwmap"
      echo " dcm run all"
      echo "und im Browser:"
      echo " http://meineserverip/kvwmap/install.php"
    ;;
    * )
      echo "OK, nix passiert!"
    ;;
  esac
}

function exists_network(){
  while read nw
  do
    if [ "$nw" = "$1" ]; then
      echo 1
      exit
    fi
  done < <(docker network ls --format {{.Name}})
  echo 0
}

function create_bridge_network() {
  if [ $(exists_network $network_name) -eq 0 ]; then
    echo "Erzeuge Docker Netzwerk ${network_name}:"
    cmd="\
      docker network create \
        --driver=bridge \
        --ip-range=$NETWORK_IP_RANGE \
        --subnet=$NETWORK_SUBNET \
      $network_name \
    "
    echo $cmd
    $cmd
  else
    echo "Docker Netzwerk ${network_name} existiert bereits"
  fi
}

#----------------------------------------------
container_version=$3
# Ab Version 3.0.0
if [ -z $3 ] ; then
  network_name="kvwmap_prod"
else
  network_name="kvwmap_$3"
fi
export network_name=$network_name

#load settings
CONFIG_FILE=$( dirname "${BASH_SOURCE[0]}" )
if [ -f $CONFIG_FILE/config/config ] ; then
  CONFIG_FILE=$CONFIG_FILE/config/config
else
  cp $CONFIG_FILE/config/config-default $CONFIG_FILE/config/config
  CONFIG_FILE=$CONFIG_FILE/config/config-default
fi

#echo "Load config file ${CONFIG_FILE}"
source $CONFIG_FILE

fail_unless_root

load_cargo

core_case_found=true

#echo "Führe Befehl aus mit Command: $1, Container: $2, Netzwerk: $3"

case "$1" in
  build)
    case $2 in
      gdal)
        build_gdal_image 'latest'
      ;;
      kvwmap)
        echo "Build the image pkorduan/kvwmap-server:${KVWMAP_IMAGE_VERSION}"
        build_kvwmap_server $KVWMAP_IMAGE_VERSION
      ;;
      *)
        echo "Gebe das Image an das gebaut werden soll. gdal oder kvwmap"
      ;;
    esac
  ;;

  cd)
    case $2 in
      apps)
        dir="web/www/apps/"
      ;;
      data)
        dir="web/www/data/"
      ;;
      apache)
        dir="web/apache2/sites-enabled/"
      ;;
      *)
        dir=""
      ;;
    esac
    echo "Wechsel in das Verzeichnis $dir von Netzwerk ${network_name}"
    cmd="cd ${USER_DIR}/networks/${network_name}/${dir}"
    echo $cmd
    $cmd
  ;;

  clean)
    echo "Lösche alle nicht genutzten Container."
    docker rm $(docker ps -q -f status=exited)

    echo "Lösche alle Images mit Namen <none>."
    docker rmi $(docker images -a | grep "^<none>" | awk '{print $3}')
  ;;

  config)
    export network_name="kvwmap_$2"
    echo "Validiere und zeige docker-compose.yaml von Netzwerk ${network_name}"
    cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml config"
    echo $cmd
    $cmd
  ;;

  console)
    case $2 in
      gdal)
        echo "Öffne ein Terminal im Container in dem gdal mit ogr2ogr läuft..."
        if [ "${network_name}" == "kvwmap_ohne" ]; then
          cmd="docker exec -it gdal /bin/bash"
        else
          cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml exec gdal /bin/bash"
        fi
        echo $cmd
        $cmd
      ;;
      mysql)
        echo "Öffne ein Terminal im Container in dem der MySQL-Server läuft..."
        if [ "${network_name}" == "kvwmap_ohne" ]; then
          cmd="docker exec -it mysql-server /bin/bash"
        else
          cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml exec mysql /bin/bash"
        fi
        echo $cmd
        $cmd
      ;;
      pgsql)
        echo "Öffne ein Terminal im Container in dem der PostgreSQL-Server läuft..."
        if [ "${network_name}" == "kvwmap_ohne" ]; then
          cmd="docker exec -it pgsql-server /bin/bash"
        else
          cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml exec pgsql /bin/bash"
        fi
        echo $cmd
        $cmd
      ;;

      proxy)
        source $USER_DIR/proxy/env_and_volumes
        echo "Öffne ein Terminal im Container in dem der Proxy läuft..."
        cmd="docker exec -it -e TERM=$TERM -e COLUMNS=$COLUMNS -e LINES=$LINES proxy /bin/bash"
        echo $cmd
        $cmd
      ;;

      web)
        echo "Öffne ein Terminal zum web container"
        if [ "${network_name}" == "kvwmap_ohne" ]; then
          cmd="docker exec -it web /bin/bash"
        else
          cmd="docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml exec web /bin/bash"
        fi
        echo $cmd
        $cmd
      ;;

      *)
        core_sub_cases="gdal, mysql, pgsql, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
  ;;

  create)
    case $2 in
      network)
        create_bridge_network
        docker network ls
      ;;
      *)
        usage
      ;;
    esac
  ;;

  inspect)
    if [[ "$2" == "network" ]] ; then
      echo "Informationen über das Netzwerk $3"
      cmd="network ${network_name}"
    else
      echo "Informationen über Container ${network_name}_$2_1 in Netz ${network_name}"
      cmd="${network_name}_$2_1"
    fi
    cmd="docker inspect $cmd"
    $cmd
    echo "Ausgeführt mit Commando: $cmd"
    ps_container
  ;;

  install)
    echo "
    Erzeuge user: ${OS_USER} ..."
    # create user for web gis anwendung if not exists
    $OS_USER_EXISTS || adduser $OS_USER
    /usr/sbin/usermod -u 17000 $OS_USER
    /usr/sbin/groupmod -g 1700 $OS_USER
    if [ ! -f /usr/bin/docker ]; then
      install_docker
    fi
    case $2 in
      all)
        install_kvwmap_images
        install_cargos
      ;;
      kvwmap)
        install_kvwmap_images
      ;;
      *)
        core_sub_cases="all, gdal, kvwmap"
        call_cargo_cases $1 $2 $3
      ;;
    esac
  ;;

  log)
    case $2 in
      pgsql)
        # Logging settings to postgresql
        sed -i \
          -e "s|#logging_collector = off|logging_collector = on|g" \
          -e "s|#log_directory = 'pg_log'|log_directory = 'pg_log'|g" \
          -e "s|#log_truncate_on_rotation = off|log_truncate_on_rotation = off|g" \
          -e "s|#log_rotation_age = 1d|log_rotation_age = 1d|g" \
          -e "s|#checkpoint_segments = 3|checkpoint_segments = 30|g" \
          -e "s|#checkpoint_timeout = 5min|checkpoint_timeout = 10min|g" \
          $DB_ROOT/postgresql/data/postgresql.conf
      ;;
      *)
        echo "Gib nach log einen der folgenden Parameter ein: pgsql."
      ;;
    esac
  ;;

  logs)
    case $2 in
      proxy)
        docker logs proxy
      ;;
      *)
        docker-compose -f /home/gisadmin/networks/${network_name}/docker-compose.yaml logs -f $2
      ;;
    esac
  ;;

  mysql)
    case $2 in
      client)
        MYSQL_TCP_ADD=`docker inspect --format '{{ .NetworkSettings.IPAddress }}' mysql-server`
        MYSQL_ROOT_PASSWORD=`docker inspect --format '{{index .Config.Env 0}}' mysql-server | cut -d \= -f 2`
        docker exec -it mysql-server mysql -h ${MYSQL_TCP_ADD} -u root --password=${MYSQL_ROOT_PASSWORD} mysql
      ;;
      start)
        docker start mysql-server
        docker ps
      ;;
      status)
        show_container_status "mysql-server"
      ;;
      stop)
        docker stop mysql-server
        docker ps -a | sort -k 2
      ;;
      remove)
        docker rm mysql-server
        docker ps -a | sort -k 2
      ;;
      tomariadb)
        migrate_to_mariadb
      ;;
      run)
        run_mysql_container
      ;;
      *)
        echo "Gib nach mysql einen der folgenden Parameter ein: client, start, status, stop, remove oder run."
      ;;
    esac
  ;;

  pgsql)
    case $2 in
      client)
        POSTGRESQL_TCP_ADD=`docker inspect --format '{{ .NetworkSettings.IPAddress }}' pgsql-server`
        PGPASSWORD=`docker inspect --format '{{index .Config.Env 0}}' pgsql-server | cut -d \= -f 2`
        docker exec -it pgsql-server psql -h ${POSTGRESQL_TCP_ADD} -U postgres postgres
      ;;
      start)
        docker start pgsql-server
        docker ps
      ;;
      status)
        show_container_status "pgsql-server"
      ;;
      stop)
        docker stop pgsql-server
        docker ps -a | sort -k 2
      ;;
      remove)
        docker rm pgsql-server
        docker ps -a | sort -k 2
      ;;
      run)
        run_pgsql_container
      ;;
      allowip)
        docker exec pgsql-server /var/lib/postgresql/data/allowip $3
      ;;
      *)
        echo "Gib nach pgsql einen der folgenden Parameter ein: client, start, status, stop, remove oder run."
      ;;
    esac
  ;;

  ps)
    if [[ -z $2 ]] ; then
      network_name=""
    else
      if [[ "$2" == kvwmap_* ]] ; then
        network_name=$2
      else
        network_name="kvwmap_$2"
      fi
    fi
    ps_container $network_name
  ;;

  rebuild)
    case $2 in
      gdal)
        stop_gdal_container
        remove_gdal_container
        docker rmi -f $(docker images -q pkorduan/gdal-sshd)
        build_gdal_image 'latest'
        run_gdal_container
      ;;
      web)
        remove_web_container
        build_kvwmap_server $KVWMAP_IMAGE_VERSION
        run_web_container
      ;;
      *)
        stop_all_container
        remove_all_container
        build_gdal_image
        build_kvwmap_server $KVWMAP_IMAGE_VERSION
        run_all_container
      ;;
    esac
    docker images
    docker ps -a | sort -k 2
  ;;

  reload)
    case $2 in
      all)
        stop_all_container
        remove_all_container
        docker rmi -f $(docker images -q pkorduan/kvwmap-server)
        docker pull pkorduan/kvwmap-server:$KVWMAP_IMAGE_VERSION
        run_all_container
        docker images
        docker ps -a | sort -k 2
      ;;
      proxy)
        reload_proxy_container
      ;;
      web)
        stop_web_container
        remove_web_container
        docker rmi -f $(docker images -q pkorduan/kvwmap-server)
        docker pull pkorduan/kvwmap-server:$KVWMAP_IMAGE_VERSION
        run_web_container
        docker images
        docker ps -a | sort -k 2
      ;;
      *)
        echo "Gib nach reload einen der folgenden Parameter ein: all oder web."
      ;;
    esac
  ;;

  rm)
    case $2 in
      all)
        stop_all_container
        remove_all_container
        docker ps -a | sort -k 2
      ;;
      proxy)
        stop_proxy_container
        remove_proxy_container
        docker ps -a | sort -k 2
      ;;
      gdal)
        stop_gdal_container
        remove_gdal_container
        docker ps -a | sort -k 2
      ;;
      mysql)
        stop_mysql_container
        remove_mysql_container
        docker ps -a | sort -k 2
      ;;
      pgsql)
        stop_pgsql_container
        remove_pgsql_container
        docker ps -a | sort -k 2
      ;;
      network)
        remove_network
        docker network ls
      ;;
      web)
        stop_web_container
        remove_web_container
        docker ps -a | sort -k 2
      ;;
      * )
        core_sub_cases="all, gdal, mysql, pgsql, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
  ;;

  rerun)
    case $2 in
      all)
        stop_all_container
        remove_all_container
        run_all_container
      ;;
      gdal)
        stop_gdal_container
        remove_gdal_container
        run_gdal_container
      ;;
      pgsql)
        stop_pgsql_container
        remove_pgsql_container
        run_pgsql_container
      ;;
      mysql)
        stop_mysql_container
        remove_mysql_container
        run_mysql_container
      ;;
      proxy)
        stop_proxy_container
        remove_proxy_container
        run_proxy_container
      ;;
      web)
        stop_web_container
        remove_web_container
        run_web_container
      ;;
      * )
        core_sub_cases="all, gdal, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
    docker ps
  ;;

  restart)
    case $2 in
      all)
        stop_all_container
        start_all_container
      ;;
      web)
        stop_web_container
        start_web_container
      ;;
      *)
        core_sub_cases="all, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
    docker ps
  ;;

  run)
    case $2 in
      all)
        run_all_container
      ;;
      proxy)
        run_proxy_container
      ;;
      gdal)
        run_gdal_container
      ;;
      kvwmap)
        run_mysql_container
        run_pgsql_container
        run_gdal_container
        run_web_container
      ;;
      mysql)
        run_mysql_container
      ;;
      pgsql)
        run_pgsql_container
      ;;
      web)
        run_web_container
      ;;
      * )
        core_sub_cases="all, gdal, kvwmap, mysql, pgsql, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
    docker ps
  ;;

  ip)
    case $2 in
      all)
        show_all_container_ips
      ;;
      gdal)
        show_container_ip $2
      ;;
      mysql)
        show_container_ip $2
      ;;
      pgsql)
        show_container_ip $2
      ;;
      web)
        show_container_ip $2
      ;;
      * )
        core_sub_cases="all, gdal, mysql, pgsql, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
  ;;

  start)
    case $2 in
      all)
        start_all_container
      ;;
      mysql)
        docker start mysql-server
      ;;
      pgsql)
        docker start pgsql-server
      ;;
      web)
        start_container $2
      ;;
      * )
        core_sub_cases="all, gdal, kvwmap, mysql, pgsql, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
    docker ps -a | sort -k 2
  ;;

  status)
    case $2 in
      all)
        show_container_status "mysql-server"
        show_container_status "pgsql-server"
        show_container_status "web"
        show_container_status "gdal"
        if type -t run_geoserver_container | grep -q "^function$" ; then
          show_container_status "geoserver"
        fi
      ;;
      gdal)
        show_container_status "gdal"
      ;;
      mysql)
        show_container_status "mysql-server"
      ;;
      pgsql)
        if [ -n "${container_version}" ] ; then
          show_container_status "pgsql-server${container_version}" /bin/bash
        else
          show_container_status "pgsql-server"
        fi
      ;;
      web)
        show_container_status "web"
      ;;
      *)
        core_sub_cases="all, gdal, mysql, pgsql, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
  ;;

  stop)
    case $2 in
      all)
        stop_all_container
      ;;
      proxy)
        stop_proxy_container
      ;;
      gdal)
        stop_gdal_container
      ;;
      mysql)
        stop_mysql_container
      ;;
      kvwmap)
        stop_web_container
        stop_pgsql_container
        stop_mysql_container
      ;;
      pgsql)
        stop_pgsql_container
      ;;
      web)
        stop_web_container
      ;;
      *)
        core_sub_cases="all, gdal, mysql, kvwmap, pgsql, web"
        call_cargo_cases $1 $2 $3
      ;;
    esac
    docker ps -a | sort -k 2
  ;;

  test)
    case $2 in
      proxy)
        test_proxy_container
      ;;
      *)
        echo "Derzeit können nur folgende Container getestet werden: proxy"
      ;;
    esac
  ;;

  uninstall)
    case $2 in
      all)
        uninstall_gdal
        uninstall_kvwmap
        uninstall_cargos
      ;;
      gdal)
        uninstall_gdal
      ;;
      kvwmap)
        uninstall_kvwmap
      ;;
      *)
        core_sub_cases="all, gdal, kvwmap"
        call_cargo_cases $1 $2 $3
      ;;
    esac
  ;;

  update)
    case $2 in
      cron)
        docker exec web /etc/cron.hourly/kvwmap
        echo "Crontab für Nutzer gisadmin im Web-Container geschrieben."
      ;;
      *)
        usage
      ;;
    esac
  ;;

  *)
    usage
    exit 1
  ;;
esac
