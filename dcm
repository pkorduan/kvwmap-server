#!/bin/bash

#load settings
CONFIG_FILE=$( dirname "${BASH_SOURCE[0]}" )
if [ -f $CONFIG_FILE/config/config ] ; then
  CONFIG_FILE=$CONFIG_FILE/config/config
else
  CONFIG_FILE=$CONFIG_FILE/config/config-default
fi

echo "Load config file ${CONFIG_FILE}"
source $CONFIG_FILE

usage() {
  echo ""
  echo "Das Script führt Anweisungen für die Verwaltung des kvwmap-Servers aus. Es muss als Nutzer root ausgeführt werden.";
  echo "Dazu gehören Befehle zum Starten und Stoppen der Container aber auch solche zum Anzeigen von Stati und Laden von Konfigurationen und sonstige häufiger für die Administration benötigten Komandos."
  echo "Kontakt: peter.korduan@gdi-service.de"
  echo ""
  echo "Aufruf:";
  echo "kvwmap [Option]";
  echo ""
  echo "Optionen:"
  echo "build gdal     Erzeugt ein neues Image pkorduan/gdal-ssh:${GDAL_IMAGE_VERSION} an Hand des lokalen Dockerfiles."
  echo "build kvwmap   Erzeugt ein neues Image pkorduan/kvwmap-server:${KVWMAP_IMAGE_VERSION} an Hand des lokalen Dockerfiles."
  echo "clean          Löscht alle beendeten Container und nicht getaggete images."
  echo "console mysql  Öffnet eine Console im Mysql Container."
  echo "console pgsql  Öffnet eine Console im PostgreSQL Container."
  echo "console web    Öffnet eine Console im Web Container"
  echo "install        - Installiert auf dem Hostrechner den Docker-Server und Utilities zum Betrieb der Container,"
  echo "               - Richtet ggf. benötigte Verzeichnisse und lokale Dateien für den Betrieb der Container ein."
  echo "install all    Installiert die Voraussetzungen zum Betrieb aller Container."
  echo "install kvwmap Installiert die Voraussetzungen zum Betrieb des web Containers."
  echo "install pydio  Installiert pydio Image."
  echo "mysql client   Öffnet eine Komandozeile im mysql Client."
  echo "mysql start    Startet nur den Container mit der MySQL-Datenbank (mysql-server)"
  echo "mysql status   Zeigt den Status des MySQL Containers an."
  echo "mysql stop     Stoppt den MySQL Container und zeigt alle vorhandenen an."
  echo "mysql remove   Löscht den MySQL Container und zeigt die verbleibenden an. Der Container muss vorher gestoppt worden sein."
  echo "mysql run      Erzeugt und startet den MySQL Container mit dem Namen mysql-server."
  echo "pgsql client   Öffnet eine Komandozeile im psql Client."
  echo "pgsql start    Startet nur den Container mit der PostgreSQL-Datenbank (pgsql-server)."
  echo "pgsql status   Zeigt den Status des PostgreSQL-Datenbank Containers an."
  echo "pgsql stop     Stoppt den PostgreSQL Container und zeigt alle vorhandenen an."
  echo "pgsql remove   Löscht den PostgreSQL Container und zeigt die verbleibenden an. Der Container muss vorher gestoppt worden sein."
  echo "pgsql run      Erzeugt und startet den PostgreSQL Container mit dem Namen pgsql-server."
  echo "rebuild        Stoppt und löscht Container, löscht images, die neu gebildet werden sollen, bildet diese neu und erzeugt und startet danach Container neu."
  echo "rebuild all    Stoppt, löscht und restartet zum rebuild des Web Containers alle Container."
  echo "rebuild gdal   Stoppt und löscht den gdal Container, löscht und rebuild das image pkorduan/gdal-ssh:${GDAL_IMAGE_VERSION} neu und run gdal Container neu."
  echo "rebuild web    Macht ein Rebuild vom image kvwmap-server:#{KVWMAP_IMAGE_VERSION}."
  echo "reload         Das selbe wie bei rebuild, nur dass nicht das image lokal neu gebuildet wird, sondern das latest von Dockerhub geladen wird."
  echo "reload all     Läd alle Container neu."
  echo "reload web     Läd nur den Web Container neu."
  echo "rm             Löscht Container."
  echo "rm all         Löscht alle Container."
  echo "rm mysql       Löscht nur den Container mysql-server."
  echo "rm pgsql       Löscht nur den Container pgsql-server."
  echo "rm web         Löscht nur den Container web."
  echo "rerun          Stoppt und löscht alle oder die angegebenen Container und erzeugt und startet sie danach wieder."
  echo "rerun all      Rerun für alle Container."
  echo "rerun gdal     Stopped und löscht nur den gdal Container und erzeugt und startet ihn anschließend neu."
  echo "rerun web      Stopped und löscht nur den web Container und erzeugt und startet ihn anschließend neu."
  echo "restart        Stoppt und löscht Container und erzeugt und startet sie neu wie beim Parameter run."
  echo "restart all    Führt es für alle Container aus."
  echo "restart web    Führt es nur für den web Container aus."
  echo "run            Erzeugt und startet alle oder den angegebenen Container."
  echo "run all        Erzeugt und startet alle Container."
  echo "run gdal       Erzeugt und startet nur den Container gdal."
  echo "run mysql      Erzeugt und startet nur den Container mysql-server."
  echo "run pgsql      Erzeugt und startet nur den Container pgsql-server."
  echo "run web        Erzeugt und startet nur den Container web."
  echo "show_ip        Zeigt die IP Adressen der Container an. Der Containername als zusätzlicher Parameter zeigt nur die IP dieses Containers an."
  echo "start          Startet alle oder den angegebenen Container."
  echo "start all      Startet alle Container."
  echo "start mysql    Startet nur den Container mysql-server."
  echo "start pgsql    Startet nur den Container pgsql-server."
  echo "start pydio    Startet nur den Container pydio."
  echo "start web      Startet nur den Container web."
  echo "status         Listet Status der angegebenen Container auf."
  echo "status all     Listet den Status aller Container auf."
  echo "status mysql   Listet den Status des Containers mysql-server."
  echo "status pgsql   Listet den Status des Containers pgsql-server."
  echo "status web     Listet den Status des Containers web"
  echo "stop           Stoppt alle oder einen der angegebenen Container."
  echo "stop all       Stoppt alle Container."
  echo "stop mysql     Stoppt nur den Container mysql-server."
  echo "stop pgsql     Stoppt nur den Container pgsql-server."
  echo "stop web       Stoppt nur den Container web."
  echo "uninstall      Vorsicht, Stoppt und löscht Container, löscht Images und deinstalliert eingerichtete Verzeichnisse auf dem Host-Rechner."
  echo "uninstall all  Deinstalliert alle images."
  echo "uninsall gdal  Deinstalliert das gdal image pkorduan/gdal-ssh:${GDAL_IMAGE_VERSION} und die dazugehörigen lokalen Ressourcen auf dem Hostrechner."
  echo "uninstall kvwmap Deinstalliert kvwmap-server."
  echo "               Dazu gehört alles in  ${WWW_ROOT} sowie die Verzeichnisse db, etc und kvwmap-server"
  echo "               unter dem Installationsverzeichnis z.B. unter /home/gisadmin"
  echo "               Damit werden auch alle Daten und Datenbankinhalte gelöscht."
  echo "update cron    Aktualisiert umgehend die cronjobs des Nutzers gisadmin im Web Container durch die Eintragungen,"
  echo "               die mit kvwmap in die Datei /var/www/cron/crontab_gisadmin geschrieben wurden."
  echo ""
  echo "Beispiele:"
  echo "$0 start"
  echo "$0 stop"
  echo "$0 pgsql status"
  echo ""
  echo "Je nach dem welche Erweiterungen in cargo-enabeld eingestellt sind gibt es weitere Befehle. Folgende sind derzeit aktiviert:"
  usage_cargos
}

usage_cargos() {
  #echo "Show usage of cargos."
  for cargo in "${CARGOS[@]}"
  do
    #echo "usage_$cargo"
    usage_$cargo
  done
}

debug() {
  if $DEBUG ; then
    echo $1
  fi
}

build_kvwmap_server() {
  TAG=$1
  if [ -z "$TAG" ] ; then
    TAG=$KVWMAP_IMAGE_VERSION
  fi
  cd $USER_DIR/kvwmap-server/docker
  docker build -t pkorduan/kvwmap-server:${TAG} .
}

build_gdal_image() {
  TAG=$1
  if [ -z "$TAG" ] ; then
    TAG="latest"
  fi
  echo "Build the image pkorduan/gdal-sshd:$TAG"
  cd $USER_DIR/gdal-sshd
  docker build -t pkorduan/gdal-sshd:$TAG .
}

call_cargo_cases() {
  debug "Call cargo cases with Arguments '$1' and '$2'"
  echo "Call cargo cases with Arguments '$1' and '$2'"
  any_case_found=false
  for cargo in "${CARGOS[@]}"
  do :
    debug "Search for case $1 $2 in cargo $cargo"
    echo "   Search for case $1 $2 in cargo $cargo cases_$cargo"
    cases_$cargo $1 $2
    if $case_found ; then
      #echo "Found case in cargo $cargo $1 $2"
      any_case_found=true
    fi
  done
  debug "Any case found after call all cargo cases: $any_case_found"
  if ! $any_case_found ; then
    echo "$any_case_found nicht gefunden"
    echo "Gib nach $1 die Parameter $core_sub_cases"
    if [ "${#CARGOS[@]}" -gt "0" ] ; then
      printf "oder %s " "${CARGOS[@]}"
    fi
    echo "an."
  fi
}

# Bricht ab, wenn nutzer nicht root ist und nicht in docker gruppe
fail_unless_root() {
  dcm_user=$(id -nu)
  dcm_user_group=$(id -nG | awk -F ' ' '{print $2}')
  # Wenn ausführender Nutzer nicht root ist
  if [ "${dcm_user}" != "root" ]; then
    # Prüfe ob ausführende Nutzer in Gruppe docker ist
    if [ "${dcm_user_group}" != "docker" ] ; then
      echo "Nutzer ${dcm_user} ist nicht berechtigt das Script dcm auszuführen."
      echo "Führen Sie das Script als root aus oder fügen Sie den Nutzer ${dcm_user} mit dem Befehhl"
      echo "usermod -a -G docker ${dcm_user}"
      echo "zur Gruppe von docker hinzu."
      exit 1
    else
      echo "${dcm_user} in gruppe ${dcm_user_group}"
    fi
  else
    echo 'root'
  fi
}

load_cargo() {
  #echo "Load cargo source code."
  #echo "Load Container Configurations in $CARGOPATH."
  #echo "Consider that they will loaded in the alphanumeric order of the symbolic links in $CARGOPATH."

  dcmfiles=($(find -L $CARGOPATH -name dcm))

  dcmfiles=($(echo "${dcmfiles[@]}" | sed 's/ /\n/g' | sort))

  for dcmfile in ${dcmfiles[@]}
  do
    echo "Load dcmfile: ${dcmfile}"
    source $dcmfile
  done
  #echo "CARGOS: "
  #printf '%s\n' "${CARGOS[@]}"
  #echo ""
}

install_cargos() {
  for cargo in "${CARGOS[@]}"
  do :
    install_$cargo
  done
}

install_docker() {
  echo "Install docker auf dem Hostrechner ..."
  # Update debian repo
  apt-get update && apt-get install -y \
    apt-utils \
    curl \
    jq \
    sendemail \
    unzip \
    wget

  # install docker demon and client on host system if not exists already
  case `docker --version` in
    *Docker*)
      echo 'Docker schon installiert!'
      ;;
    *)
      echo 'Installiere docker ....'
      curl -sSL https://get.docker.com/ | sh
    ;;
  esac
  
  # enable memory and swap accounting. This prevent from
  # WARNING: Your kernel does not support cgroup swap limit. and
  # WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.
  # This setting affects only after rebooting the system
  sed -i \
    -e "s|GRUB_CMDLINE_LINUX=\"\"|GRUB_CMDLINE_LINUX=\"cgroup_enable=memory swapaccount=1\"|g" \
    /etc/default/grub
  update-grub
}

install_kvwmap_images() {
  echo "Installiere Voraussetzungen für den Betrieb von kvwmap ..."
  
  echo "
  Erzeuge user: ${OS_USER} ..."
  # create user for web gis anwendung if not exists
  $OS_USER_EXISTS || adduser $OS_USER
  usermod -u 17000 $OS_USER
  groupmod -g 1700 $OS_USER
  usermod -a -G docker $OS_USER
  
  echo "
  Setze bash Einstellungen für user: ${OS_USER} ..."
  # set bash settings for web gis user
  cp /etc/skel/.bashrc $USER_DIR/.bashrc
  echo "
  export PATH=\$PATH:${USER_DIR}/kvwmap-server" >> $USER_DIR/.bashrc
  sed -i \
    -e "s|#alias ll=|alias ll=|g" \
    -e "s|alias rm=|#alias rm=|g" \
    $USER_DIR/.bashrc
  cp $USER_DIR/.bashrc ~/.bashrc
  source ~/.bashrc

  echo "Erzeuge www_root Verzeichnis."
  mkdir -p $WWW_ROOT

  echo "Kopiere www Verzeichnisse die vordefinierte Daten enthalten, apps, cron, data, html."
  cp -R $USER_DIR/kvwmap-server/www/* $WWW_ROOT

  echo "
  Erzeuge restliche Verzeichnisstruktur für die Datenbank und Web-Anwendungen von kvwmap ..."
  # create directories
  mkdir -p $DB_ROOT/mysql \
           $DB_ROOT/postgresql/data \
           $USER_DIR/etc \
           $WWW_ROOT/logs \
           $WWW_ROOT/logs/apache2 \
           $WWW_ROOT/logs/cron \
           $WWW_ROOT/logs/pgsql \
           $WWW_ROOT/logs/mysql \
           $WWW_ROOT/tmp \
           $WWW_ROOT/cache \
           $WWW_ROOT/wms \
           $WWW_ROOT/data/synchro \
           $WWW_ROOT/data/upload \
           $WWW_ROOT/data/druckrahmen \
           $WWW_ROOT/data/bilder \
           $WWW_ROOT/data/alb \
           $WWW_ROOT/data/nachweise \
           $WWW_ROOT/data/recherchierte_antraege \
           $WWW_ROOT/data/festpunkte/archiv

  ln -s $WWW_ROOT $USER_DIR/www
  ln -s $DB_ROOT $USER_DIR/db

  echo "
  Kopiere Konfigurationsdateien für Apache Web-Server ..."
  cp -R $USER_DIR/kvwmap-server/etc/apache2 $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/gdal $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/mysql $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/postgresql $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/php5 $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/phpmyadmin $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/proj $USER_DIR/etc/
  cp -R $USER_DIR/kvwmap-server/etc/web $USER_DIR/etc/

  echo "
  Erzeuge Unterverzeichnisse im Apache Konfigurationsverzeichnis..."
  mkdir -p $USER_DIR/etc/apache2/sites-enabled \
           $USER_DIR/etc/apache2/ssl \
           $USER_DIR/etc/apache2/letsencrypt

  echo "
  Erzeuge Links für den Zugriff auf die Datenbankverzeichnisse ..."
  # create links to have access to the postgres config files, even if the files do not exist yet
  ln -s $DB_ROOT/postgresql/data/pg_hba.conf $USER_DIR/etc/postgresql/pg_hba.conf
  ln -s $DB_ROOT/postgresql/data/postgresql.conf $USER_DIR/etc/postgresql/postgresql.conf

  echo "
  Setze Servername für Apache default Konfiguration ..."
  # Servername in Apache default Konfiguration eintragen
  sed -i -e "s|ServerName localhost|ServerName ${SERVER_NAME}|g" $USER_DIR/etc/apache2/sites-available/000-default.conf

  echo "
  Clone kvwmap von github ins Web-Verzeichnis ..."
  if [ ! -d "${WWW_ROOT}/apps/kvwmap" ]; then
    # clone kvwmap repository into apps
    git clone https://github.com/srahn/kvwmap.git $WWW_ROOT/apps/kvwmap
    cd $WWW_ROOT/apps/kvwmap
    git checkout develop
  fi

  echo "
  Erzeuge kvwmap custom Verzeichnisse für Fonts, Grafik, Symbole und Layouts ..."
  mkdir -p $WWW_ROOT/apps/kvwmap/fonts/custom \
           $WWW_ROOT/apps/kvwmap/graphics/custom \
           $WWW_ROOT/apps/kvwmap/layouts/custom \
           $WWW_ROOT/apps/kvwmap/layouts/snippets/custom \
           $WWW_ROOT/apps/kvwmap/symbols/custom

  cd $WWW_ROOT/apps

  echo "
  Setze Rechte auf kvwmap Datenverzeichnisse ..."
  chown -R $OS_USER.$OS_USER $USER_DIR $WWW_ROOT
  chmod -R g+w $WWW_ROOT

  echo "
  Setze Rechte auf logs Verzeichnisse ..."
  chown 999.gisadmin $WWW_ROOT/logs/pgsql
  chmod a+r $WWW_ROOT/logs/pgsql

  echo "
  Setze Rechte 600 auf .pgpass ..."
  chmod 600 $USER_DIR/etc/postgresql/.pgpass

  echo "
  Nächste Schritte zum installieren von kvwmap:"
  echo "    $ dcm run all"
  echo "    Browser öffnen mit der Adresse: https://${IP_EXTERN}/kvwmap/install.php"
  echo ""
  echo "Die Installation ist erfolgreich abgeschlossen."
}

is_stopped() {
  if [ "$(docker ps -a -q -f name=$1 -f status=exited)" ] ; then
    echo 'true'
  else
    echo 'false'
  fi;
}

is_running() {
  if [ "$(docker inspect --format="{{ .State.Running }}" $1 2> /dev/null)" == "true" ] ; then
    echo 'true';
  else
    echo 'false';
  fi;
}

remove_all_container() {
  echo "Lösche alle Container ..."
  docker rm $(docker ps -a -q)
  echo "Alle Container gelöscht."
}

remove_gdal_container() {
  stop_gdal_container

  if [ "$(docker ps -a -q -f name=gdal -f status=exited)" ] ; then
    echo "Lösche Container ..."
    docker rm gdal
  else
    echo "Container gdal kann nicht gelöscht werden, weil er nicht existiert."
  fi
}

remove_mysql_container() {
  stop_mysql_container

  if [ "$(docker ps -a -q -f name=mysql-server -f status=exited)" ] ; then
    echo "Lösche Container ..."
    docker rm mysql-server
  else
    echo "Container mysql-server kann nicht gelöscht werden, weil er nicht existiert."
  fi
}

remove_pgsql_container() {
  stop_pgsql_container

  if [ "$(docker ps -a -q -f name=pgsql-server -f status=exited)" ] ; then
    echo "Lösche Container ..."
    docker rm pgsql-server
  else
    echo "Container pgsql-server kann nicht gelöscht werden, weil er nicht existiert."
  fi
}

remove_web_container() {
  stop_web_container

  if [ "$(docker ps -a -q -f name=web -f status=exited)" ] ; then
    echo "Lösche Container ..."
    docker rm web
  else
    echo "Container web kann nicht gelöscht werden, weil er nicht existiert."
  fi
}

remove_all_images() {
  echo "Lösche alle Images ..."
  docker rmi $(docker images | awk "{print $3}")
  echo "Alle Images gelöscht."
}

run_all_container() {
  echo "Erzeuge und Starte alle Container ..."
  run_mysql_container
  if type -t run_oracle_container | grep -q "^function$" ; then
    run_oracle_container
  fi
  run_pgsql_container
  run_gdal_container
  if type -t run_geoserver_container | grep -q "^function$" ; then
    run_geoserver_container
  fi
  if type -t run_tomcat_container | grep -q "^function$" ; then
    run_tomcat_container
  fi
  if type -t run_pydio_container | grep -q "^function$" ; then
    run_pydio_container
  fi
  if type -t run_owncloud_container | grep -q "^function$" ; then
    run_owncloud_container
  fi
  if type -t run_deegree_container | grep -q "^function$" ; then
    run_deegree_container
  fi
  if type -t run_osm2po_container | grep -q "^function$" ; then
    run_osm2po_container
  fi
  if type -t run_bucardo_container | grep -q "^function$" ; then
    run_bucardo_container
  fi
  run_web_container
}

run_cargo_containers() {
  for cargo in "${CARGOS[@]}"
  do
    run_${cargo}_container
  done
}

run_gdal_container() {
  echo "Erzeuge und Starte container gdal"

  source $USER_DIR/etc/gdal/env_and_volumes
  echo  ${SERVER_NAME}-gdal-container 
  echo "docker run --name gdal \
-h ${SERVER_NAME}-gdal-container \
--link pgsql-server:pgsql \
$gdal_env_vars \
$gdal_volumes \
$gdal_ports \
--restart=always \
-d ${GDAL_IMAGE}:${GDAL_IMAGE_VERSION}"

  docker run --name gdal \
    -h ${SERVER_NAME}-gdal-container \
    --link pgsql-server:pgsql \
    $gdal_env_vars \
    $gdal_volumes \
    $gdal_ports \
    --restart=always \
    -d ${GDAL_IMAGE}:${GDAL_IMAGE_VERSION}
}

run_mysql_container() {
  echo "Erzeuge und Starte container mysql"

  source $USER_DIR/etc/mysql/env_and_volumes

  docker run --name mysql-server \
    -h ${SERVER_NAME}-mysql-container \
    $mysql_env_vars \
    $mysql_volumes \
    --restart=always \
    -d ${MYSQL_IMAGE}:${MYSQL_IMAGE_VERSION}
}

run_pgsql_container() {
  echo "Erzeuge und Starte container pgsql"

  source $USER_DIR/etc/postgresql/env_and_volumes
  if [ -z "$pgsql_ports" ] ; then
    pgsql_ports="-p 5432:5432"
  fi

  if [ -z "${PGSQL_CONTAINER_NAME}" ] ; then
    PGSQL_CONTAINER_NAME="pgsql-server"
  fi

  set_cargo_pgsql_links

  echo "run pgsql container with command: docker run --name ${PGSQL_CONTAINER_NAME} \
    -h ${SERVER_NAME}-${PGSQL_CONTAINER_NAME} \
    $CARGO_PGSQL_LINKS \
    $pgsql_env_vars \
    $pgsql_volumes \
    $pgsql_ports \
    --restart=always \
    -d ${PGSQL_IMAGE}:${PGSQL_IMAGE_VERSION}"

  docker run --name ${PGSQL_CONTAINER_NAME} \
    -h ${SERVER_NAME}-${PGSQL_CONTAINER_NAME} \
    $CARGO_PGSQL_LINKS \
    $pgsql_env_vars \
    $pgsql_volumes \
    $pgsql_ports \
    --restart=always \
    -d ${PGSQL_IMAGE}:${PGSQL_IMAGE_VERSION}
}

run_web_container() {
  echo "Erzeuge und Starte container web"
 
  source $USER_DIR/etc/web/env_and_volumes
  if [ -z "${web_hosts}" ]; then
    web_hosts="--add-host=$SERVER_NAME.$DOMAIN_NAME:${IP_EXTERN} \
               --add-host=$SERVER_NAME:${IP_EXTERN}"
  fi
  set_cargo_web_links

	echo "run web container with command: docker run --name web \
    -h ${SERVER_NAME}-web-container \
    --link mysql-server:mysql \
    --link pgsql-server:pgsql \
    --link gdal:gdal \
    $CARGO_WEB_LINKS \
    $web_env_vars \
    $web_volumes \
    $web_hosts \
    -p 80:80 \
    -p 443:443 \
    --restart=always \
    -d ${KVWMAP_IMAGE}:${KVWMAP_IMAGE_VERSION}"

  docker run --name web \
    -h ${SERVER_NAME}-web-container \
    --link mysql-server:mysql \
    --link pgsql-server:pgsql \
    --link gdal:gdal \
    $CARGO_WEB_LINKS \
    $web_env_vars \
    $web_volumes \
    $web_hosts \
    -p 80:80 \
    -p 443:443 \
    --restart=always \
    -d ${KVWMAP_IMAGE}:${KVWMAP_IMAGE_VERSION}
}

set_cargo_web_links() {
  for cargo in "${CARGOS[@]}"
  do :
    set_${cargo}_web_link
  done
}

set_cargo_pgsql_links() {
  for cargo in "${CARGOS[@]}"
  do :
    if type -t set_${cargo}_pgsql_link | grep -q "^function$" ; then
      set_${cargo}_pgsql_link
    fi
  done
}

show_all_container_ips() {
  docker inspect -f="Container {{.Name}} IP: {{.NetworkSettings.IPAddress}}" $(docker ps -aq)
}

show_container_ip() {
  docker inspect -f="Container {{.Name}} IP: {{.NetworkSettings.IPAddress}}" $1
}

show_container_status() {
  CONTAINER=$1
  echo "Status des Containers $CONTAINER:"
  RUNNING=$(docker inspect --format="{{ .State.Running }}" $CONTAINER 2> /dev/null)
 
  if [ $? -eq 1 ]; then
    echo "UNKNOWN - Container $CONTAINER does not exist."
    return 3
  fi
 
  if [ "$RUNNING" == "false" ]; then
    echo "CRITICAL - $CONTAINER is not running."
    return 2
  fi

  STARTED=$(docker inspect --format="{{ .State.StartedAt }}" $CONTAINER)
  NETWORK=$(docker inspect --format="{{ .NetworkSettings.IPAddress }}" $CONTAINER)
 
  echo "OK - $CONTAINER is running. IP: $NETWORK, StartedAt: $STARTED"
}

start_all_container() {
  echo "Startet alle existierenden Container."
  docker start mysql-server
  docker start pgsql-server
  
  # start_cargo_container

  start_gdal_container
  start_web_container
  docker ps
}

start_container() {
  container=$1
  if [ ! -z $container ] ; then
    if [ "$(is_running $container)" == "true" ]; then
      echo "Container $container läuft schon.";
    else
      if [ "$(is_stopped $container)" == "false" ]; then
        run_${container}_container
      else
        echo "Starte Container ${container} ..."
        docker start $container
      fi
    fi
  fi
}

start_gdal_container() {
  echo "Starte gdal Container."
  docker start gdal
}

start_web_container() {
  echo "Starte web Container."
  docker start web
}

stop_all_container() {
  echo "Stoppe alle Container. Bitte warten ..."
  docker stop $(docker ps -a -q)
  echo "Alle Container gestopped."
}

stop_container() {
  container=$1
  if [ ! -z $container ] ; then
    RUNNING=$(is_running $container)
    if [ "$RUNNING" == "true" ]; then
      echo "Stoppe Container $container ..."
      docker stop $container
    fi
  fi
}

stop_gdal_container() {
  if [ "$(docker ps -a -q -f name=gdal -f status=running)" ] ; then
    echo "Stoppe Container. Bitte warten ..."
    docker stop gdal
  else
    echo "Container gdal kann nicht gestoppt werden, weil er nicht läuft."
  fi
}

stop_mysql_container() {
  if [ "$(docker ps -a -q -f name=mysql-server -f status=running)" ] ; then
    echo "Stoppe Container. Bitte warten ..."
    docker stop mysql-server
  else
    echo "Container mysql-server kann nicht gestoppt werden, weil er nicht läuft."
  fi
}

stop_pgsql_container() {
  if [ "$(docker ps -a -q -f name=pgsql-server -f status=running)" ] ; then
    echo "Stoppe Container. Bitte warten ..."
    docker stop pgsql-server
  else
    echo "Container pgsql-server kann nicht gestoppt werden, weil er nicht läuft."
  fi
}

stop_web_container() {
  stop_container web
}

uninstall_cargos() {
  for cargo in "${CARGOS[@]}"
  do :
    uninstall_$cargo
  done
}

uninstall_gdal() {
  echo "Deinstalliere das gdal image ..."
  echo "Funktion ist noch nicht implementiert!!!"
}

uninstall_kvwmap() {
  echo "Deinstalliere das kvwmap und dazugehörige images."
  read -p "Wollen Sie kvwmap-server wirklich deinstallieren? (j/n)? " answer
  case ${answer:0:1} in
    j|J )
      stop_all_container
      remove_all_container
      remove_all_images
      echo "Lösche alles in ${WWW_ROOT} "
      ls -l $WWW_ROOT
      rm -RI $WWW_ROOT/*

      if [ ! -z "$USER_DIR" ] ; then
        echo "Lösche $DB_ROOT, $USER_DIR/etc, $USER_DIR/kvwmap-server, ${WWW_ROOT} und die links db und www in $USER_DIR"
        rm -RI $DB_ROOT $USER_DIR/etc $USER_DIR/kvwmap-server $WWW_ROOT $USER_DIR/db $USER_DIR/www
      fi
      echo "So jetzt ist alles weg."
      echo "Zum neu installieren nach ${USER_DIR} wechseln und folgenden Befehle eingeben:"
      echo " git clone https://github.com/pkorduan/kvwmap-server.git"
      echo " kvwmap-server/dcm install kvwmap"
      echo " dcm run all"
      echo "und im Browser:"
      echo " http://meineserverip/kvwmap/install.php"
    ;;
    * )
      echo "OK, nix passiert!"
    ;;
  esac
}

fail_unless_root

load_cargo

core_case_found=true

case "$1" in
  build)
    case $2 in
      gdal)
        build_gdal_image 'latest'
      ;;
      kvwmap)
        echo "Build the image pkorduan/kvwmap-server:${KVWMAP_IMAGE_VERSION}"
        build_kvwmap_server $KVWMAP_IMAGE_VERSION
      ;;
      *)
        echo "Gebe das Image an das gebaut werden soll. gdal oder kvwmap"
      ;;
    esac
  ;;

  clean)
    echo "Lösche alle nicht genutzten Container."
    docker rm $(docker ps -q -f status=exited)
    
    echo "Lösche alle Images mit Namen <none>."
    docker rmi $(docker images -a | grep "^<none>" | awk '{print $3}')
  ;;

  console)
    case $2 in
      gdal)
        echo "Öffne ein Terminal im Container in dem gdal mit ogr2ogr läuft..."
        docker exec -it gdal /bin/bash
      ;;
      mysql)
        echo "Öffne ein Terminal im Container in dem der MySQL-Server läuft..."
        docker exec -it mysql-server /bin/bash
      ;;
      pgsql)
        echo "Öffne ein Terminal im Container in dem der PostgreSQL-Server läuft..."
        docker exec -it pgsql-server /bin/bash
        #docker exec -it -e TERM=$TERM -e COLUMNS=$COLUMNS -e LINES=$LINES pgsql-server /bin/bash # Option -e erst ab Versiom 1.25+ unterstützt
      ;;

      web)
        echo "Öffne ein Terminal im Container in dem der Web-Server läuft..."
        docker exec -it web /bin/bash
      ;;
      *)
        core_sub_cases="gdal, mysql, pgsql, web"
        call_cargo_cases $1 $2
      ;;
    esac
  ;;

  install)
    if [ ! -f /usr/bin/docker ]; then
      install_docker
    fi
    case $2 in
      all)
        install_kvwmap_images
        install_cargos
      ;;
      kvwmap)
        install_kvwmap_images
      ;;
      *)
        core_sub_cases="all, gdal, kvwmap"
        call_cargo_cases $1 $2
      ;;
    esac
  ;;
  
  log)
    case $2 in
      pgsql)
        # Logging settings to postgresql
        sed -i \
          -e "s|#logging_collector = off|logging_collector = on|g" \
          -e "s|#log_directory = 'pg_log'|log_directory = 'pg_log'|g" \
          -e "s|#log_truncate_on_rotation = off|log_truncate_on_rotation = off|g" \
          -e "s|#log_rotation_age = 1d|log_rotation_age = 1d|g" \
          -e "s|#checkpoint_segments = 3|checkpoint_segments = 30|g" \
          -e "s|#checkpoint_timeout = 5min|checkpoint_timeout = 10min|g" \
          $DB_ROOT/postgresql/data/postgresql.conf
      ;;
      *)
        echo "Gib nach log einen der folgenden Parameter ein: pgsql."
      ;;
    esac
  ;;

  mysql)
    case $2 in
      client)
        MYSQL_TCP_ADD=`docker inspect --format '{{ .NetworkSettings.IPAddress }}' mysql-server`
        MYSQL_ROOT_PASSWORD=`docker inspect --format '{{index .Config.Env 0}}' mysql-server | cut -d \= -f 2`
        docker exec -it mysql-server mysql -h ${MYSQL_TCP_ADD} -u root --password=${MYSQL_ROOT_PASSWORD} mysql
      ;;
      start)
        docker start mysql-server
        docker ps
      ;;
      status)
        show_container_status "mysql-server"
      ;;
      stop)
        docker stop mysql-server
        docker ps -a
      ;;
      remove)
        docker rm mysql-server
        docker ps -a
      ;;
      run)
        run_mysql_container
      ;;
      *)
        echo "Gib nach mysql einen der folgenden Parameter ein: client, start, status, stop, remove oder run."
      ;;
    esac
  ;;

  pgsql)
    case $2 in
      client)
        POSTGRESQL_TCP_ADD=`docker inspect --format '{{ .NetworkSettings.IPAddress }}' pgsql-server`
        PGPASSWORD=`docker inspect --format '{{index .Config.Env 0}}' pgsql-server | cut -d \= -f 2`
        docker exec -it pgsql-server psql -h ${POSTGRESQL_TCP_ADD} -U postgres postgres
      ;;
      start)
        docker start pgsql-server
        docker ps
      ;;
      status)
        show_container_status "pgsql-server"
      ;;
      stop)
        docker stop pgsql-server
        docker ps -a
      ;;
      remove)
        docker rm pgsql-server
        docker ps -a
      ;;
      run)
        run_pgsql_container
      ;;
      *)
        echo "Gib nach pgsql einen der folgenden Parameter ein: client, start, status, stop, remove oder run."
      ;;
    esac
  ;;

  ps)
    docker ps $2
  ;;
  
  rebuild)
    case $2 in
      gdal)
        stop_gdal_container
        remove_gdal_container
        docker rmi -f $(docker images -q pkorduan/gdal-sshd)
        build_gdal_image 'latest'
        run_gdal_container
      ;;
      web)
        remove_web_container
        build_kvwmap_server $KVWMAP_IMAGE_VERSION
        run_web_container
      ;;
      *)
        stop_all_container
        remove_all_container
        build_gdal_image 
        build_kvwmap_server $KVWMAP_IMAGE_VERSION
        run_all_container
      ;;
    esac
    docker images
    docker ps -a
  ;;

  reload)
    case $2 in
      all)
        stop_all_container
        remove_all_container
        docker rmi -f $(docker images -q pkorduan/kvwmap-server)
        docker pull pkorduan/kvwmap-server:$KVWMAP_IMAGE_VERSION
        run_all_container
      ;;
      web)
        remove_web_container
        docker rmi -f $(docker images -q pkorduan/kvwmap-server)
        docker pull pkorduan/kvwmap-server:$KVWMAP_IMAGE_VERSION
        run_web_container
      ;;
      *)
        echo "Gib nach reload einen der folgenden Parameter ein: all oder web."
      ;;
    esac
    docker images
    docker ps -a
  ;;

  rm)
    case $2 in
      all)
        stop_all_container
        remove_all_container
      ;;
      gdal)
        remove_gdal_container
      ;;
      mysql)
        remove_mysql_container
      ;;
      pgsql)
        remove_pgsql_container
      ;;
      web)
        remove_web_container
      ;;
      * )
        core_sub_cases="all, gdal, mysql, pgsql, web"
        call_cargo_cases $1 $2
      ;;
    esac
    docker ps -a
  ;;

  rerun)
    case $2 in
      all)
        stop_all_container
        remove_all_container
        run_all_container
      ;;
      gdal)
        stop_gdal_container
        remove_gdal_container
        run_gdal_container
      ;;
      web)
        remove_web_container
        run_web_container
      ;;
      * )
        core_sub_cases="all, gdal, web"
        call_cargo_cases $1 $2
      ;;
    esac
    docker ps
  ;;

  restart)
    case $2 in
      all)
        stop_all_container
        start_all_container
      ;;
      web)
        stop_web_container
        start_web_container
      ;;
      *)
        core_sub_cases="all, web"
        call_cargo_cases $1 $2
      ;;
    esac
    docker ps
  ;;
  
  run)
    case $2 in
      all)
        run_all_container
      ;;
      gdal)
        run_gdal_container
      ;;
      kvwmap)
        run_mysql_container
        run_pgsql_container
        run_gdal_container
        run_web_container
      ;;
      mysql)
        run_mysql_container
      ;;
      pgsql)
        run_pgsql_container
      ;;
      web)
        run_web_container
      ;;
      * )
        core_sub_cases="all, gdal, kvwmap, mysql, pgsql, web"
        call_cargo_cases $1 $2
      ;;
    esac
    docker ps
  ;;

  ip)
    case $2 in
      all)
        show_all_container_ips
      ;;
      gdal)
        show_container_ip $2
      ;;
      mysql)
        show_container_ip $2
      ;;
      pgsql)
        show_container_ip $2
      ;;
      web)
        show_container_ip $2
      ;;
      * )
        core_sub_cases="all, gdal, mysql, pgsql, web"
        call_cargo_cases $1 $2
      ;;
    esac
  ;;
  
  start)
    case $2 in
      all)
        start_all_container
      ;;
      mysql)
        docker start mysql-server
      ;;
      pgsql)
        docker start pgsql-server
      ;;
      web)
        start_container $2
      ;;
      * )
        core_sub_cases="all, gdal, kvwmap, mysql, pgsql, web"
        call_cargo_cases $1 $2
      ;;
    esac
    docker ps -a
  ;;

  status)
    case $2 in
      all)
        show_container_status "mysql-server"
        show_container_status "pgsql-server"
        show_container_status "web"
        show_container_status "gdal"
        if type -t run_geoserver_container | grep -q "^function$" ; then
          show_container_status "geoserver"
        fi
      ;;
      gdal)
        show_container_status "gdal"
      ;;
      mysql)
        show_container_status "mysql-server"
      ;;
      pgsql)
        show_container_status "pgsql-server"
      ;;
      web)
        show_container_status "web"
      ;;
      *)
        core_sub_cases="all, gdal, mysql, pgsql, web"
        call_cargo_cases $1 $2
      ;;
    esac
  ;;

  stop)
    case $2 in
      all)
        stop_all_container
      ;;
      gdal)
        stop_gdal_container
      ;;
      mysql)
        stop_mysql_container
      ;;
      kvwmap)
        stop_web_container
        stop_pgsql_container
        stop_mysql_container
      ;;
      pgsql)
        stop_pgsql_container
      ;;
      web)
        stop_web_container
      ;;
      *)
      core_sub_cases="all, gdal, mysql, kvwmap, pgsql, web"
      call_cargo_cases $1 $2
      ;;
    esac
    docker ps -a
  ;;
  
  uninstall)
    case $2 in
      all)
        uninstall_gdal
        uninstall_kvwmap
        uninstall_cargos
      ;;
      gdal)
        uninstall_gdal
      ;;
      kvwmap)
        uninstall_kvwmap
      ;;
      *)
        core_sub_cases="all, gdal, kvwmap"
        call_cargo_cases $1 $2
      ;;
    esac
  ;;

  update)
    case $2 in
      cron)
        docker exec web /etc/cron.hourly/kvwmap
        echo "Crontab für Nutzer gisadmin im Web-Container geschrieben." 
      ;;
      *)
        usage
      ;;
    esac
  ;;

  *)
    usage
    exit 1
  ;;
esac
